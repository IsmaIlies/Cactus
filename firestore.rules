rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function hasAdminRole() { return request.auth != null && (request.auth.token.admin == true); }

    match /users/{userId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null && request.auth.uid == userId;
    }

    match /typingStatus/{docId} {
      allow read, write: if request.auth != null;
    }

    match /sales/{saleId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null && (request.auth.uid == resource.data.userId || hasAdminRole());
    }

    match /leads_sales/{saleId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.resource.data.mission == "ORANGE_LEADS"
        && request.resource.data.origineLead in ["hipto", "dolead", "mm"]
        && request.resource.data.mobileCount is number
        && request.resource.data.boxCount is number
        && request.resource.data.numeroId is string
        && request.resource.data.typeOffre is string
        && request.resource.data.telephone is string
        && (
          request.resource.data.createdAt is timestamp ||
          request.resource.data.createdAt == request.time
        );
      allow update, delete: if false;
    }

    match /messages/{messageId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.senderId
        && request.resource.data.sender is string
        && request.resource.data.text is string
        && request.resource.data.channel is string
        && (
          request.resource.data.channel in ['public','public_fr','public_civ'] ||
          (request.resource.data.participants is list &&
           request.resource.data.participants.size() == 2 &&
           request.auth.uid in request.resource.data.participants) ||
          (request.resource.data.participantA is string &&
           request.resource.data.participantB is string &&
           request.auth.uid in [request.resource.data.participantA, request.resource.data.participantB])
        );
      allow update, delete: if request.auth != null && (request.auth.uid == resource.data.senderId || hasAdminRole());
    }

    // Programme PDF partagé : lecture ouverte à tous (même non connectés), écriture restreinte
    match /shared/programmePdf {
      allow read: if true; // accessible publiquement
      function isPdfPublisher() {
        return hasAdminRole() || (
          request.auth != null && (
            request.auth.token.email == 'i.boultame@mars-marketing.fr' ||
            request.auth.token.email == 'j.allione@mars-marketing.fr' ||
            request.auth.token.email == 'i.brai@mars-marketing.fr'
          )
        );
      }
      allow create, update, delete: if isPdfPublisher();
    }

    // Interactions Programme PDF (likes + commentaires) - collections aplaties
    // programmePdfLikes/{userId} : { createdAt }
    // programmePdfComments/{commentId} : { userId, text, createdAt }
    match /programmePdfLikes/{userId} {
      allow read: if true;
      // Create: only owner; payload only { createdAt }
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['createdAt'])
        && request.resource.data.createdAt is timestamp;
      // Delete: only owner; don't reference request.resource (undefined on delete)
      allow delete: if request.auth != null && request.auth.uid == userId;
      // No updates needed (like doc is immutable except deletion)
      allow update: if false;
    }
    match /programmePdfComments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.text is string
        && request.resource.data.text.size() > 0
        && request.resource.data.text.size() <= 1000
        && request.resource.data.createdAt is timestamp;
      allow delete: if request.auth != null && (hasAdminRole() || request.auth.uid == resource.data.userId);
      allow update: if false;
    }

    // --- Game / Casino features ---
    // gameCredits/{userId} documents: { userId, credits, startingCredits, updatedAt }
    // Only the owner (or admin) can create/update their own credits doc. Reads require auth.
    match /gameCredits/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId; // each user reads own credits
      allow create: if request.auth != null && request.auth.uid == userId
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.credits is number
        && request.resource.data.startingCredits is number
        && request.resource.data.updatedAt is timestamp;
      allow update: if request.auth != null && request.auth.uid == userId
        && request.resource.data.credits is number
        && request.resource.data.updatedAt is timestamp;
      allow delete: if false; // prevent deletion by clients
    }

    // betsCasino: bets placed between users. Allow read to involved users; creation requires auth.
    match /betsCasino/{betId} {
      allow read: if request.auth != null; // broad read (adjust if sensitive)
      allow create: if request.auth != null
        && request.resource.data.bettorUserId == request.auth.uid
        && request.resource.data.targetUserId is string
        && request.resource.data.stake is number
        && request.resource.data.status == 'open'
        && request.resource.data.createdAt is timestamp
        && request.resource.data.targetSalesBaseline is number;
      // status/resolution updates only by admin for now (or could be Cloud Function)
      allow update: if hasAdminRole();
      allow delete: if false;
    }

    // betHistory log entries (append-only)
    match /betHistory/{eventId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.resource.data.betId is string
        && request.resource.data.type in ['created','resolved']
        && request.resource.data.bettorUserId is string
        && request.resource.data.targetUserId is string
        && request.resource.data.stake is number
        && request.resource.data.targetSalesBaseline is number
        && request.resource.data.ts is timestamp;
      allow update, delete: if false;
    }

    // Suggestions (FAQ & idées) : lecture publique, création requiert auth, modifications réservées admin
    match /suggestions/{suggestionId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if hasAdminRole();
    }

    // Todos utilisateurs : accessibles uniquement au propriétaire (sous-collection users/{userId}/todos/{todoId})
    match /users/{userId}/todos/{todoId} {
      allow read, create: if request.auth != null && request.auth.uid == userId;
      allow update, delete: if request.auth != null && request.auth.uid == userId;
    }

    match /{document=**} {
      allow read: if request.auth != null;
    }
  }
}
