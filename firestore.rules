rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Historique et messages de l'assistant IA : chaque utilisateur peut lire/écrire ses propres conversations et messages
    match /users/{userId}/chatHistories/{historyId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/chatHistories/{historyId}/messages/{messageId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    function hasAdminRole() { return request.auth != null && (request.auth.token.admin == true); }
    // Supervisors FR (Canal+) authorized for attendance writes
    function isFrSupervisor() {
      return hasAdminRole() || (
        request.auth != null && (
          request.auth.token.email == 'i.brai@mars-marketing.fr' ||
          request.auth.token.email == 'i.boultame@mars-marketing.fr' ||
          request.auth.token.email == 'j.allione@mars-marketing.fr'
        )
      );
    }
    // Rôles autorisés à publier/mettre à jour les PDFs (programme & nouveautés)
    function isPdfPublisher() {
      return hasAdminRole() || (
        request.auth != null && (
          request.auth.token.email == 'i.boultame@mars-marketing.fr' ||
          request.auth.token.email == 'j.allione@mars-marketing.fr' ||
          request.auth.token.email == 'i.brai@mars-marketing.fr'
        )
      );
    }

    // --- Présence Canal+ FR (attendance) ---
    // attendance/{docId} where docId = "FR_YYYY-MM-DD"
    match /attendance/{docId} {
      // Authenticated read (can be opened wider later)
      allow read: if request.auth != null;
      // Create requires at least region/date; entries optional initially
      allow create: if isFrSupervisor()
        && request.resource.data.region == 'FR'
        && request.resource.data.date is string;
      // Updates may send partial merges (region/date omitted); validate existing doc region
      allow update: if isFrSupervisor()
        && resource.data.region == 'FR';
      // No client-side deletes
      allow delete: if false;
    }

    // Roster settings for Canal+ FR (list of agents for attendance UI)
    match /settings/canal_fr_roster {
      allow read: if request.auth != null;
      allow create, update: if isFrSupervisor()
        && request.resource.data.keys().hasOnly(['agents'])
        && request.resource.data.agents is list;
      allow delete: if false;
    }

    match /users/{userId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null && request.auth.uid == userId;
    }

    match /typingStatus/{docId} {
      allow read, write: if request.auth != null;
    }

    match /sales/{saleId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null && (request.auth.uid == resource.data.userId || hasAdminRole());
    }

    match /leads_sales/{saleId} {
      allow read: if true;
      allow create, update, delete: if true;
    }

    match /messages/{messageId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.senderId
        && request.resource.data.sender is string
        && request.resource.data.text is string
        && request.resource.data.channel is string
        && (
          request.resource.data.channel in ['public','public_fr','public_civ'] ||
          (request.resource.data.participants is list &&
           request.resource.data.participants.size() == 2 &&
           request.auth.uid in request.resource.data.participants) ||
          (request.resource.data.participantA is string &&
           request.resource.data.participantB is string &&
           request.auth.uid in [request.resource.data.participantA, request.resource.data.participantB])
        );
      allow update, delete: if request.auth != null && (request.auth.uid == resource.data.senderId || hasAdminRole());
    }

    // Programme PDF partagé : lecture ouverte à tous (même non connectés), écriture restreinte
    match /shared/programmePdf {
      allow read: if true; // accessible publiquement
      allow create, update, delete: if isPdfPublisher();
    }

    // Nouveautés PDF partagé : lecture publique, écriture restreinte (mêmes éditeurs que programme)
    match /shared/noveltiesPdf {
      allow read: if true;
      allow create, update, delete: if isPdfPublisher();
    }

    // Nouvelle collection multi-docs pour les Nouveautés PDF
    // Chaque doc correspond à un PDF (name,size,storagePath,url,active,createdAt,updatedAt,updatedBy,version)
    match /novelties/{docId} {
      allow read: if true;
      allow create, update, delete: if isPdfPublisher();
    }

    // Interactions Nouveautés: sous-collections par document
    // likes: novelties/{docId}/likes/{userId} -> { createdAt }
    // views: novelties/{docId}/views/{userId} -> { firstAt?, lastAt }
    // comments: novelties/{docId}/comments/{commentId} -> { userId, text, createdAt }
    match /novelties/{docId}/likes/{userId} {
      allow read: if true;
      // Create only by the owner; payload must be { createdAt }
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['createdAt'])
        && request.resource.data.createdAt is timestamp;
      // Delete only by the owner
      allow delete: if request.auth != null && request.auth.uid == userId;
      // No updates
      allow update: if false;
    }
    match /novelties/{docId}/views/{userId} {
      allow read: if true;
      // Owner can create or update their view timestamps
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['firstAt','lastAt'])
        && (request.resource.data.firstAt is timestamp || !(request.resource.data.keys().hasAny(['firstAt'])))
        && request.resource.data.lastAt is timestamp;
      allow update: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['firstAt','lastAt'])
        && (request.resource.data.firstAt is timestamp || !(request.resource.data.keys().hasAny(['firstAt'])))
        && request.resource.data.lastAt is timestamp;
      allow delete: if false;
    }
    match /novelties/{docId}/comments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.text is string
        && request.resource.data.text.size() > 0
        && request.resource.data.text.size() <= 1000
        && request.resource.data.createdAt is timestamp;
      allow delete: if request.auth != null && (hasAdminRole() || request.auth.uid == resource.data.userId);
      allow update: if false;
    }

    // Interactions Programme PDF (likes + commentaires) - collections aplaties
    // programmePdfLikes/{userId} : { createdAt }
    // programmePdfComments/{commentId} : { userId, text, createdAt }
    match /programmePdfLikes/{userId} {
      allow read: if true;
      // Create: only owner; payload only { createdAt }
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['createdAt'])
        && request.resource.data.createdAt is timestamp;
      // Delete: only owner; don't reference request.resource (undefined on delete)
      allow delete: if request.auth != null && request.auth.uid == userId;
      // No updates needed (like doc is immutable except deletion)
      allow update: if false;
    }
    match /programmePdfComments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.text is string
        && request.resource.data.text.size() > 0
        && request.resource.data.text.size() <= 1000
        && request.resource.data.createdAt is timestamp;
      allow delete: if request.auth != null && (hasAdminRole() || request.auth.uid == resource.data.userId);
      allow update: if false;
    }

    // Catalogue des intitulés d'offres LEADS (lecture publique, écriture admin ou éditeurs autorisés)
    function isCatalogPublisher() {
      return hasAdminRole() || (
        request.auth != null && (
          request.auth.token.email == 'i.brai@mars-marketing.fr' ||
          request.auth.token.email == 'i.boultame@mars-marketing.fr' ||
          request.auth.token.email == 'j.allione@mars-marketing.fr'
        )
      );
    }
    match /leads_config/offers {
      allow read: if true;
      // Allow any authenticated user to create or update the catalogue (import/publish)
      // Restrict deletion to original catalog publishers / admins
      allow create, update: if request.auth != null;
      allow delete: if isCatalogPublisher();
    }

    // --- Game / Casino features ---
    // gameCredits/{userId} documents: { userId, credits, startingCredits, updatedAt }
    // Only the owner (or admin) can create/update their own credits doc. Reads require auth.
    match /gameCredits/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId; // each user reads own credits
      allow create: if request.auth != null && request.auth.uid == userId
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.credits is number
        && request.resource.data.startingCredits is number
        && request.resource.data.updatedAt is timestamp;
      allow update: if request.auth != null && request.auth.uid == userId
        && request.resource.data.credits is number
        && request.resource.data.updatedAt is timestamp;
      allow delete: if false; // prevent deletion by clients
    }

    // betsCasino: bets placed between users. Allow read to involved users; creation requires auth.
    match /betsCasino/{betId} {
      allow read: if request.auth != null; // broad read (adjust if sensitive)
      allow create: if request.auth != null
        && request.resource.data.bettorUserId == request.auth.uid
        && request.resource.data.targetUserId is string
        && request.resource.data.stake is number
        && request.resource.data.status == 'open'
        && request.resource.data.createdAt is timestamp
        && request.resource.data.targetSalesBaseline is number;
      // status/resolution updates only by admin for now (or could be Cloud Function)
      allow update: if hasAdminRole();
      allow delete: if false;
    }

    // betHistory log entries (append-only)
    match /betHistory/{eventId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.resource.data.betId is string
        && request.resource.data.type in ['created','resolved']
        && request.resource.data.bettorUserId is string
        && request.resource.data.targetUserId is string
        && request.resource.data.stake is number
        && request.resource.data.targetSalesBaseline is number
        && request.resource.data.ts is timestamp;
      allow update, delete: if false;
    }

    // Suggestions (FAQ & idées) : lecture publique, création requiert auth, modifications réservées admin
    match /suggestions/{suggestionId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if hasAdminRole();
    }

    // Todos utilisateurs : accessibles uniquement au propriétaire (sous-collection users/{userId}/todos/{todoId})
    match /users/{userId}/todos/{todoId} {
      allow read, create: if request.auth != null && request.auth.uid == userId;
      allow update, delete: if request.auth != null && request.auth.uid == userId;
    }

    // --- Heures (checklists) ---
    function isHoursSupervisor() {
      // Supervisor gate by admin claim OR approved supervisor emails
      return hasAdminRole() || (
        request.auth != null && (
          request.auth.token.email == 'i.brai@mars-marketing.fr' ||
          request.auth.token.email == 'i.boultame@mars-marketing.fr' ||
          request.auth.token.email == 'j.allione@mars-marketing.fr'
        )
      );
    }

    // hoursEntries: agents create/update their own docs; supervisors/admins can update for review
    match /hoursEntries/{entryId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
        && request.resource.data.userId is string
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.day is string
        && request.resource.data.period is string
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      // Autoriser tout utilisateur authentifié à modifier uniquement les champs innocents (supervisor et/ou project)
      // en vérifiant les clés modifiées via diff() (et non la totalité des clés du document)
      allow update: if request.auth != null && (
          (
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['supervisor','updatedAt'])
          ) || (
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['project','updatedAt'])
          ) || (
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['supervisor','project','updatedAt'])
          ) || (
            // Propriétaire ou superviseur/admin pour les autres modifications
            (request.auth.uid == resource.data.userId || isHoursSupervisor()) &&
            request.resource.data.updatedAt is timestamp
          )
        );
  // Allow supervisors/admins to delete checklist entries
  allow delete: if isHoursSupervisor();
    }

    // Optional aggregation per user/period
    match /hoursPeriods/{docId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null
        && request.resource.data.userId is string
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.period is string
        && request.resource.data.updatedAt is timestamp;
      allow delete: if false;
    }

    // Heures mensuelles par agent (supervision): écriture contrôlée côté front, schéma validé ici
    match /leads_prod_hours_monthly/{docId} {
      allow read: if request.auth != null;
      // Ouvrir en écriture aux comptes authentifiés, avec validation stricte du schéma
      // NOTE: à resserrer si besoin (par rôle superviseur) via hasAdminRole() ou un filtre email
      allow create, update: if request.auth != null
        && request.resource.data.keys().hasOnly(['monthKey','monthStart','agentLabel','hours','updatedAt'])
        && request.resource.data.monthKey is string
        && request.resource.data.agentLabel is string
        && request.resource.data.hours is number
        && request.resource.data.hours >= 0
        && request.resource.data.monthStart is timestamp;
      allow delete: if false;
    }

    // Par défaut, on n'ouvre pas en écriture mais on autorise lecture publique
    // pour éviter les erreurs permission-denied sur du contenu non sensible affiché publiquement.
    match /{document=**} {
      allow read: if true;
    }
  }
}
